## 基本概念
### 类的封装
类封装了数据和数据上的操作，这点和结构体很像，C里面结构体里面套函数指针也可以实现类似的封装。
而且C++对于`struct`关键字还做了加强，在结构体里面也能写函数，也有访问控制，如：
```cpp
struct myS
{
private:
public:
  void func()
  {
    ...
  }
protected:
};
```
唯一的区别就是`struct`里默认属性的为`public`，而`class`默认属性为`private`。

`#pragma once`的作用就是**防止一个头文件被重复包含**，和
```cpp
#ifndef _MYTEACHER_H_
#define _MYTEACHER_H_
...
#endif
```
的作用是一样的

### 对象的构造和析构
#### 构造函数分类
* 无参数构造函数
* 带参数构造函数
* 拷贝构造函数
* 如果不显示定义构造函数，C++编译器会自己提供**默认**无参构造函数和**默认**的拷贝构造函数
  * 默认无参构造函数：函数体为**空**
  * 默认拷贝构造函数：对成员变量简单值拷贝，即**浅拷贝**
**无参数构造函数和带参数构造函数**
```cpp
class Test
{
	int m_a;
	int m_b;
public:
	Test()
	{
		m_a = 0;
		m_b = 0;
		std::cout << "无参数的构造函数\n";
	}
	Test(int a)
	{
		m_a = a;
		m_b = 0;
		std::cout << "带一个参数的构造函数\n";
	}
	Test(int a, int b)
	{
		m_a = a;
		m_b = b;
		std::cout << "带参数的构造函数\n";
	}
	Test(const Test& x) //必须写成引用，const可加可不加，最好是常引用防止实参被修改
	{
    m_a = x.m_a;
    m_b = x.m_b;
		std::cout << "拷贝构造函数\n";
	}
};
int main()
{
  //调用无参数构造函数
	Test a1;
  //调用带参数构造函数的三种方法：
  //1.括号法
	Test a2(1, 2);
  //2.直接调用法，涉及到匿名对象
	Test a3 = Test(3, 4);
  //3.赋值法，(1, 2)是个逗号表达式值为2，最终调用的是带一个参数的构造函数
	Test a4 = (1, 2);
	return 0;
}
```
带参数构造函数的第二种方法，还有个`=`难道不会再次涉及到一次赋值构造吗？
答案是**不会**，方法2**只调用一次**带参数的构造函数就完成了a3的**构造和初始化**。这是现代C++的特性，对于匿名对象的直接转换。

* 区分赋值和初始化：
```cpp
Test b;
Test a = Test(3, 4); //定义处通过带参数的构造函数初始化
a = b; //这是对象的赋值
```
**拷贝构造函数**
* 为什么可以访问引用参数的私有数据？
因为访问控制是针对类来讲而不是针对对象，拷贝构造函数在类的内部，当然可以访问它的`private`数据。
* 初始化时
```cpp
Test a1(1, 2); //带参数的构造函数

Test a2 = a1; // 初始化法，定义a2用拷贝构造函数初始化
Test a3(a1); // 括号法
```
* 函数形参
```cpp
int func(Test p)
{
  cout << p.getx(); //形参会在func结束时调用析构函数析构掉
}
int main()
{
  Test a1(1, 2);
  func(a1); //函数调用时会调用拷贝构造函数，初始化形参变量
}
```
如果函数参数是个**引用**的话，就**不用拷贝**了，形参就是对象的别名。

* 函数返回值
```cpp
Test func()
{
  Test a(1, 2);
  return a;
}
```
函数返回对象时，做法如下：
a调用拷贝构造函数构造一个**匿名对象**，随后a调用析构函数析构
也就是函数实际上返回的是一个**匿名对象**。

之后**分情况**：
```cpp
Test b = func(); //这时不再调用拷贝构造函数去构造b，而是直接将匿名对象转换成b，因此它不会被析构而是有了名字b

Test c;
c = func(); //这是赋值操作，不涉及构造函数，匿名对象在赋值c之后会被析构掉
```
