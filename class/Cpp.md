## 基本概念
### 类的封装
类封装了数据和数据上的操作，这点和结构体很像，C里面结构体里面套函数指针也可以实现类似的封装。
而且C++对于`struct`关键字还做了加强，在结构体里面也能写函数，也有访问控制，如：
```cpp
struct myS
{
private:
public:
  void func()
  {
    ...
  }
protected:
};
```
唯一的区别就是`struct`里默认属性的为`public`，而`class`默认属性为`private`。

`#pragma once`的作用就是**防止一个头文件被重复包含**，和
```cpp
#ifndef _MYTEACHER_H_
#define _MYTEACHER_H_
...
#endif
```
的作用是一样的

### 对象的构造和析构
#### 构造函数分类
* 无参数构造函数
* 带参数构造函数
* 拷贝构造函数
* 如果不显示定义构造函数，C++编译器会自己提供**默认**无参构造函数和**默认**的拷贝构造函数
  * 默认无参构造函数：函数体为**空**
  * 默认拷贝构造函数：对成员变量简单值拷贝，即**浅拷贝**
**无参数构造函数和带参数构造函数**
```cpp
class Test
{
	int m_a;
	int m_b;
public:
	Test()
	{
		m_a = 0;
		m_b = 0;
		std::cout << "无参数的构造函数\n";
	}
	Test(int a)
	{
		m_a = a;
		m_b = 0;
		std::cout << "带一个参数的构造函数\n";
	}
	Test(int a, int b)
	{
		m_a = a;
		m_b = b;
		std::cout << "带参数的构造函数\n";
	}
	Test(const Test& x) //必须写成引用，const可加可不加，最好是常引用防止实参被修改
	{
    m_a = x.m_a;
    m_b = x.m_b;
		std::cout << "拷贝构造函数\n";
	}
};
int main()
{
  //调用无参数构造函数
	Test a1;
  //调用带参数构造函数的三种方法：
  //1.括号法
	Test a2(1, 2);
  //2.直接调用法，涉及到匿名对象
	Test a3 = Test(3, 4);
  //3.赋值法，(1, 2)是个逗号表达式值为2，最终调用的是带一个参数的构造函数
	Test a4 = (1, 2);
	return 0;
}
```
带参数构造函数的第二种方法，还有个`=`难道不会再次涉及到一次赋值构造吗？
答案是**不会**，方法2**只调用一次**带参数的构造函数就完成了a3的**构造和初始化**。这是现代C++的特性，对于匿名对象的直接转换。

* 区分赋值和初始化：
```cpp
Test b;
Test a = Test(3, 4); //定义处通过带参数的构造函数初始化
a = b; //这是对象的赋值
```
**拷贝构造函数**
* 为什么可以访问引用参数的私有数据？
因为访问控制是针对类来讲而不是针对对象，拷贝构造函数在类的内部，当然可以访问它的`private`数据。
* 初始化时
```cpp
Tset(const Test &p)//参数一般为const引用
{
 ...
}
Test a1(1, 2); //带参数的构造函数

Test a2 = a1; // 初始化法，定义a2用拷贝构造函数初始化
Test a3(a1); // 括号法
```
* 函数形参
```cpp
int func(Test p)
{
  cout << p.getx(); //形参会在func结束时调用析构函数析构掉
}
int main()
{
  Test a1(1, 2);
  func(a1); //函数调用时会调用拷贝构造函数，初始化形参变量
}
```
如果函数参数是个**引用**的话，就**不用拷贝**了，形参就是对象的别名。

* 函数返回值
```cpp
Test func()
{
  Test a(1, 2);
  return a;
}
```
函数返回对象时，做法如下：
a调用拷贝构造函数构造一个**匿名对象**，随后a调用析构函数析构
也就是函数实际上返回的是一个**匿名对象**。

之后**分情况**：
```cpp
Test b = func(); //这时不再调用拷贝构造函数去构造b，而是直接将匿名对象转换成b，因此它不会被析构而是有了名字b

Test c;
c = func(); //这是赋值操作，不涉及构造函数，匿名对象在赋值c之后会被析构掉
```
> 关于匿名对象：
> ```cpp
> Test(1, 2);
> ```
> 这个匿名对象，执行这一行结束，将调用构造函数和析构函数，也就是这句话一结束，匿名对象就被析构了，**生命周期就只有这一行**，因为没人接它：要么初始化别人转正，要么赋值给别人后被析构。
> 比如：
> ```cpp
> class A
> {
> 	A(int a, int b, int c)
> 	{
> 		m_a = a;
> 		m_b = b;
> 		m_c = c;
>	}
>	A(int a, int b)
>	{
>		m_a = a;
>		m_b = b;
>		A(a, b, 100); //这句话就是生成个匿名对象，而且声明周期就这一行，也就是说m_c没有被赋值
>	}
> }
> int main()
> {
> 	A(1, 2);
> 	cout << c;
> }
> ```
> 输出c不是10，而是个乱码

#### 深拷贝和浅拷
默认拷贝构造函数实现的**就是浅拷贝**，只能简单的将值复制。
如果对象属性有**指针**并且指向**堆区**的一块内存，那么浅拷贝后两个对象的那个指针属性将指向堆区同一块内存，这就是浅拷贝，如果一个对象释放掉这个内存的话另一个对象的**指针就悬挂了**。

我们想要的拷贝是两个对象各自指向**自己的**内存，并且内存里的内容相等，这就是深拷贝。
**深拷贝只能手动编写实现**，分配了新的内存空间。显然深拷贝之后，指针变量的值是不一样的，毕竟指向了不同的内存，只是内存里存的东西是一样的。

这里还是要注意初始化和赋值的区别：
```cpp
Test a = b; //初始化，调用拷贝构造函数
Test c;
c = b; //赋值，使用C++提供的默认等号操作
```
等号操作符 C++默认**也是浅拷贝**，因此要想让赋值也是深拷贝，必须**显式重载等号操作符**

#### 构造函数初始化列表
如果类中包含另一个类，即对象成员，如果该对象成员的类**没有**默认构造函数而定义了带参数的构造函数，那用参数初始化对象成员只能在**初始化列表**上实现，放在构造函数内会报错
类中的**const属性**，**必须**通过初始化列表来初始化
```cpp
class A
{
private:
	Test m_a;
	Test m_b;
	int m_b;
public:
	A(): m_b(2), m_a(1)
	{;}
	
	A()       //会报错
	{m_a(1);}
}
```
初始化的顺序是和定义顺序一致，于初始化列表的顺序**无关**。执行完初始化列表后，再执行函数体。

#### 构造函数和析构函数的调用顺序
对象里组合了其他对象，先调用其他对象的构造函数，最后调用自己的。**析构顺序和构造顺序相反**。

### 动态分配内存
C++和C的区别：
* C中是`malloc`和`free`，是函数
* C++中是`new`和`delete`，和`sizeof`一样是操作符，效率更高
* **更重要的**，`new`和`delete`创建和销毁**对象**时，可以**自动调用**构造函数和析构函数，而`malloc`和`free`**无法做到**这一点。因此可以`Test *p = new Test(10)`这样带参数构造。
```cpp
//分配一块内存
int *p = (int *)malloc(sizeof(int));
free(p);
int *p1 = new int;
delete p1;

//分配数组
int *p = (int *)malloc(sizeof(int)*10);
free(p);
int *p1 = new int[10];
delete []p1;  //注意区别，释放数组必须要delete[]
```

### 静态成员变量和成员函数
* 静态成员变量，表示该类的所有对象，共享这一个静态变量
* 静态成员函数，**只能访问类中的静态成员变量**
为什么？
```cpp
class A
{
private:
	int m_a;
	int m_b;
	static int m_c;
public:
	static void func()
	{
		cout << m_a; //报错
		cout << m_c; //只能访问静态成员
	}	
}
int A::m_c = 0; //静态数据成员的初始化
int main()
{
	A::func();
	A a;
	a.func();
}
```
* 因为只有**静态成员**才允许通过类名限定来访问:`A::func()`，`A::m_c`。而如果用`A::func()`访问的静态函数中引用了普通成员，类A下有很多对象，将**无法确定到底引用的是哪个对象**，而该类静态成员变量确定只有一个，因此可以访问。

### C++面向对象模型
* 数据成员和成员函数分开存储
* 数据成员
	* 静态成员：存储在全局数据区
 	* 非静态成员： 存在栈区，布局和struct相似
* 成员函数：存储在**代码区**中
	* 普通函数：调用时隐式传入**对象的this指针** ，来确定访问哪个对象
	* 静态函数：调用时不会传入this，因此无法访问普通变量，只能访问静态成员变量
 	* 虚函数

* this指针
```cpp
void getadd() const
{
	m_x = 1; // 报错
	cout << m_x;
}
```
用const修饰**成员函数**表示函数体禁止修改`this`指针所指向的对象，这是因为原本的`this`编译成`Test char* const this`，而用`const`修饰函数体后，`this`指针编译成了`const Test char* const this`。
**通过this指针返回对象自身的引用**
```cpp
//add是一个成员函数
Test& add(Test &t2)
{
	this->m_a += t2.m_a; //this->可写可不写，毕竟在类的内部
	this->m_b += t2.m_b;
	return *this;
}
```
我们知道不能返回局部对象的引用，因为函数一结束引用的内存就被销毁掉了，这里返回的`*this`在函数结束后可不会被销毁，它是安全的内存。

### 友元函数和友元类
一般我们都把类中的数据成员设置成`private`，这确实安全。但是访问数据只能用`getaddr()`这种接口函数，实在太傻，由于访问控制导致使用起来反而不如结构体那么来的直接痛快。
友元函数和友元类就是解决这个问题的，在类的内部**声明**友元函数/友元类，那么该友元函数/友元类就可以像结构体那样，直接访问私有数据成员。比如：
```cpp
class A
{
friend class B; //B是A的友元类
private:
	int m_a;
	int m_b;
public:
	friend void func(const A&x, const A&y); //func是A的友元函数
	friend void func1(A *p1, A *p2); // func1也是A的友元函数
}
void func(const A&x, const A&y)
{
	cout << x.m_a << y.m_b; //直接访问A的私有数据成员
}
void func1(A *p1, A *p2)
{
	cout << p1->m_a < p2->m_b; //用指针也可以直接访问A的嘶有数据成员
}

class B
{
private:
	A a;
public:
	void func()
	{
		cout << a.m_a << a.m_b; //由于B是A的友元类，因此即使在类A外部也可以直接访问A的私有数据
	}
}
```
从上面例子可以看出，B是A的友元类。它的用法就是B里面组合了一个A对象，然后A将B声明为友元类，之后就可以通过B来直接修改A了。
A基本就像一个辅助类，类似于E-R图中的**弱实体**，是为了让B去用它的。比如圆和点的关系，圆类中组合一个点作为圆心，圆心把圆设置成友元类方便其操作，也是一种**辅助作用**。

### 运算符重载
用来给自定义数据类似一种简单的操作方法，运算符重载的**本质就是函数**，只不过**函数名**形式为`operator?`，其中`?`就是一个运算符，比如`+,-,++,--,>,<,==`等等。
事实上重载操作符后：
```cpp
Test operator+(Test &a, Test &b)
{
	...
}
Test t1, t2;
Test t3 = operator+(t1, t2);
Test t4 = t1 + t2;
```
其中`operator+(t1, t2)`和`t1 + t2`是**完全一样**的。
#### 一般写法
成员函数比全局函数**少一个左操作数参数**而已，就是默认传入的this指针。
* 作为全局函数(一般**定义成类的友元函数**)：
	* 二元运算符：+ - * / 
	```cpp
	class Test
	{
	friend Test operator+(Test &a, Test &b); //将全局函数声明为友元函数
	friend Test& operator++(Test &a);
	friend Test operator++(Test &a, int);
	}
	
	Test operator+(Test &a, Test &b); //a b分别为左操作数和右操作数
	```
	* 一元运算符： ++ --
	```cpp
	Test& operator++(Test &a) //前置++，返回自身
	{
		a.m_a++;
		a.m_b++;
		return a;
	}
	Test operator++(Test &a, int) //后置++，int是个占位参数
	{
		Test tmp(a.m_a+1, a.m_b+1);
		return tmp; //返回一个匿名对象
	}
	```
* 作为成员函数：用this指针隐式当作**左操作数**
	* 二元运算符：+ - * /  
	```cpp
	Test operator+(Test &b) //左操作数被隐含了，编译器自动用this指针填充
	{
		Test tmp(m_a + b.m_a, m_b + b.m_b);
		return tmp; //返回了个匿名对象
	}
	```
	* 一元运算符： ++ -- 后置操作的**int占位语法**
	```cpp
	Test& operator++() //前置++，返回自身
	{
		this->m_a++;
		m_b++;
		return *this;
	}
	Test operator++(int) //后置++，int是个占位参数
	{
		Test tmp(m_a+1, this->m_b+1);
		return tmp; //返回一个匿名对象
	}
	```
* 这个后置操作的占位int，我感觉这种语法也是迫不得已，因为重载函数不能通过返回值区分，如果单纯一个返回自身一个返回匿名对象的话编译都通不过，为了区分前置后置来了个占位int，记住就好emmm估计还是为了兼容C吧
* 其实就是写函数，重点在于返回值的判断，也就是**是否需要当左值**。如果像+ - * /这样返回一个结果只用当右值，那么直接返回匿名对象即可，返回值为`Test`; 而像前置++ --这样返回值**需要当左值**，**函数要当左值就返回引用**；而如果是关系运算符比如`> < >= <= ==`那么返回值就是`bool`类型，简单判断一下即可。
* 到底用友元函数实现还是成员函数实现？
  最好还是用成员函数实现吧，友元还破坏了封装性hhh。捏麻麻声明和定义分开写我都受不了，写代码能不能有点人性？
#### 只能用友元函数重载 >> <<
* 什么时候用友元函数实现？
  **无法修改左操作数类**的时候，比如输入输出符号`<< >>`，`cout << a`中`cout`是左操作数，如果非得用成员函数重载的话必须得修改类`ostream`的代码，这很难hhh，所以这个时候只能友元函数了。
```cpp
ostream& operator<<(ostream &out, const Test &a) //左操作数右操作数都不能少
{
	out << "m_a is" << a.m_a << "m_b is" << a.m_b;
	return out;
}
istream& operator>>(istream &in, Test &a)
{
	cout << "please input the a:" << endl;
	in >> a.m_a;
	cout << "please input the b:" << endl;
	in >> a.m_b;
	return in;
}
Test a(1, 2);
std::cout << a << "asdads";
```
最后返回引用支持**链式编程**，hh毕竟`cout`还要**当左值**嘛，肯定必须得返回引用喽。
* 还有比如运算符的左右操作数类型不同
```cpp
Test a(1, 2);
a + 27; //可以正确调用成员函数
27 + a; //无法调用，因为左操作数不是类
```
这时候只能友元函数实现一个
```cpp
Test operaotr+(int a, const Test &a)
```

#### 对赋值=操作符的重载
=操作符的结合顺序是**从右向左**的
和拷贝构造函数那里遇到的问题一样，即深浅拷贝的问题。因此一般如果要手动实现拷贝构造函数的话，=操作符也需要被重载。
而且这个如果浅拷贝的话更严重，不光是同一块内存被一个对象释放掉的指针悬挂问题，而且由于c原本分配了堆区内存的话，一浅拷贝内存就泄漏了。
```cpp
Test a(1, 2), c(3, 4);
c = a;
```
=操作符的重载**只能用成员函数实现**：
```cpp
Test& operator=(const Test &a)
{
	if(&a == this) return *this; //防止自身赋值
	if(m_p != NULL)
		delete [] m_p;  //释放原本的内存防止泄漏
	m_p = new char[30];
	strcpy(m_p, a.m_p);
	return *this; //返回自身用于链式编程
}
```

#### 对[]的重载
[]是个二元运算符！像数组那样`A[1] = 10`，显然需要当左值，因此返回引用是必须的。
```cpp
int& operator[](int &i)
{
	return this->array[i];
}
```
至于对()的重载就不写了，这玩意不会真有人用吧，写法和生成匿名对象的写法一样还容易混淆，谁知道是重载的()还是带参数的构造函数

#### 关系操作符
重载一个重载一片，clion自动生成的也是这样
```cpp
bool operator>(const Test &a)
{
	if(this->m_a > a.m_a || this->m_b > a.m_b)
		return truel
	return false;
}
bool operator<=(const Test &a)
{
	return !((*this) > a); //>已经被重载了直接用
}
```
#### 为什么不要重载&&, ||
&& 和 || 都有**短路原则**，可以省略某个式子的计算。
而操作符重载是通过函数实现的，操作数作为函数的参数，**函数参数都会被求值**，因此无法实现短路。

## 继承和派生
> 面向对象四个特点：抽象，封装，继承和多态。之前的内容讲了抽象和封装，还有什么jb操作符重载都往后稍稍，在多态面前没有任何牌面。接下来的**继承和多态才是面向对象的精华**，是面向对象方法论的核心部分。
### 继承的访问控制
三种，`public, private, protected`
```cpp
class Parent
{
private:
...
public:
...
protected:
...
}
class Child : public/protected/private Parent
{

}
```
父类的`private`属性和函数只能自己看，无法被继承。只有父类的`public`和`protected`**属性和函数**会被子类继承，并且不管怎么继承在**子类内部**都能正常使用。
这玩意细分太麻烦，一般如果要用继承的话就是用`public`继承，毕竟这样父类属性和函数在子类中的访问**访问控制不变**，比较好区分。

### 类型/赋值兼容性原则
**`public`派生**得到的子类，满足以下兼容规则：
* 子类对象可以直接**当作父类对象使用**，子类对象可以直接**赋值**给父类对象
* 父类指针或者引用可以直接**指向或者引用**子类对象 -------->**实现多态的基础**
```cpp
class Parent
{
}
class Child : public Parent
{
}
int main()
{
	Child c;
	Parent p = c; //直接用子类对象初始化和赋值父类对象
	Parent* p1 = &c; //父类指针或者引用指向子类对象
	Parent &p2 = c;
}
```
### 继承中的对象模型
之前我们已经知道了C++的类模型中，数据成员和成员函数分开存储，成员函数在代码区通过`this`指针与具体对象绑定，数据成员的内存分配和结构体类似，一般就分配在栈区。类的静态数据成员只有一个存储在静态区。
继承就是子类成员+父类成员。
![image](https://user-images.githubusercontent.com/55400137/149291455-3e79bd99-0f2d-43db-9e20-c32f4e89823d.png)
![image](https://user-images.githubusercontent.com/55400137/149291527-ad64a790-1e98-4cac-a345-9ff4be23e6dc.png)
子类继承了父类的数据成员，加上自己的数据成员形成更大的结构体而已。
这就涉及到一个问题，子类该如何初始化这些继承来的数据成员，即构造和析构

### 继承中的构造和析构
* 原则：
  	子类构造时，先调用父类的构造函数初始化继承来的数据成员，然后调用自己的构造函数初始化自己新增的成员；
  	析构时，先调用自己的析构函数，再调用父类的析构函数。
还是利用成员初始化列表，像组合那样。
```cpp
class Child : public Parent
{
	Child(int a, b, c): Parent(a, b), m_c(c)
	{}
}
```
只是简单赋值的话初始化列表还是方便，函数体都不用写。

**遵循先构造的后析构**

### 既有继承又有组合的构造和析构
* 原则：
  	构造时，先构造父类，再构造组合对象，最后构造自己；
  	析构时，先析构自己，再析构组合对象，最后析构父类

还是用初始化列表
```cpp
class Child : public Parent
{
	Test A;
	Obj B;
	Child(int a, b, c): Parent(a, b), A(a, b), B(c), m_c(c)
	{}
}
```
别忘了构造的顺序和初始化列表的顺序无关，和**定义**的顺序一致。
**同样遵循先构造的后析构**

### 子类和父类有同名数据成员/成员函数
注意内存模型，子类还是继承了父类的所有数据成员，只不过默认访问的子类的成员，要想访问父类需要类型限定`Parent::func(), Parent::m_a`。

![image](https://user-images.githubusercontent.com/55400137/149300267-93033ca9-9a1a-4855-a81e-3f9002cf958d.png)

![image](https://user-images.githubusercontent.com/55400137/149300266-0a5a74a8-71e8-4f8c-ba8e-f9cd99d4531c.png)

### 多继承-->虚继承
基本被摒弃了，像Java就没有多继承的概念了，取而代之的是接口的概念，即C++里的抽象类。
多继承可能出现二义性的问题，比如继承的多个父类有相同的爷爷类，如果用普通的方法继承访问爷爷类会出现**二义性**：
![image](https://user-images.githubusercontent.com/55400137/149302627-ab00d69b-3c77-402f-aa72-c6dfc1b988e4.png)

访问`c.B`时不知道访问哪个，因此为了解决这种问题，引入**虚继承**：

![image](https://user-images.githubusercontent.com/55400137/149302939-6da33571-507c-4df2-ae96-0a486874bcf1.png)

即使用`virtual`关键字后，编译器对`B`的构造函数**只调用一次**，从而避免了二义性。
## 多态
封装突破了C语言函数的概念，继承实现了代码的简单复用
多态可以满足**开闭原则**，是**设计模式**的基础，是**框架**的基础。

### 使用方法
**多态成立**三个条件：
* 要有继承
* 虚函数重写override
* **父类**指针/引用指向子类对象。
这是面向对象的精髓所在。

而C语言指针的最大意义就是**间接赋值**：
* 定义形参和实参
* 实参取地址给形参建立关联
* 在函数中通过* p间接修改实参的值

### 多态原理
#### 静态绑定和动态绑定
* 静态绑定在编译器**编译阶段**就已经**确定了**要调用哪个函数，已经确定了**函数的入口地址**，比如**重载函数**，写好代码之后**编译阶段**就可以根据参数列表来确定具体要调用的函数是哪一个。
* 而动态绑定则是只能在**运行**的时候根据代码的动作来确定调用哪个函数，比如`if`和`switch`语句就需要根据**运行时**的条件来判断最终调用哪个函数。

而C++也是静态绑定型的语言，需要经过编译处理，如果：
```cpp
class Parent
{
public:
	void func()   //不写virtual关键字！
	{
		cout << "parent!" << endl;
	}
}
class Chlild : public Parent
{
public:
	void func()
	{
		cout << "Child!" << endl;
	}
}
int main()
{
	Child c;
	Parent *p = &c;
	p->func();
}
```
由于没有写`virtual`关键字，因此编译阶段**只会执行静态绑定**，这时编译器的操作是：`p`指针是个`Parent`指针，我**不清楚**`p`在运行时具体指向的到底是`Parent`还是`Child`，所以我要静态绑定，**一律绑定到父类的`func()`**，因此最后输出`parent!`。这就是静态绑定的特性。

#### 虚函数表相关(vtbl&vptr)
实现多态的理论基础是**函数指针**做函数参数，捏麻麻看来我在C的回调函数那里的猜测是对的。因为vtbl里面就存了一堆函数指针，而这些函数指针都是固定类型的，因为重写**被重写的函数在父类子类中函数类型完全一致**，这就相当于抽象出了**固定不变**的东西，我们只需要按照函数的类型给出不同的实现，然后用指针指过去就OK了，这不就是妥妥的多态嘛。

即虚函数表和指向虚函数表的指针。
多态/动态绑定的一种常见实现方式：
* 当类声明是`virtual`虚函数时，**编译器**会给类创建一个虚函数表，里面存放该类**所有虚函数的入口地址**，其实就是一堆**函数指针**。
* 该对象的内存空间会多出一个指向虚函数表的指针vptr，这个指针一般是类的第一个成员。因此一般sizeof会发现**多出4个字节**，就是那个vptr。
* 通过指针调用函数时，运行时编译器根据指针指向的对象内存，取其vptr找到vptl，然后在表中找对应函数指针调用即可。因为编译器最多只能将代码`p->func()`编译成：
  `(*(*(vtbl *)p))(p)`的形式，`p`是对象的指针，先强制类型转换成`vtbl*`再取地址得到虚函数表的地址，之后再取地址得到虚函数表**首元素的地址**，即第一个函数指针，传入`p`相当于`this`指针，就实现了调用。
  也就是说编译器最后还得看**运行**的时候`p`到底指向的谁，这就是动态绑定。

> 虚函数表是和类相关的，只要在类中**声明**了虚函数就会创建虚函数表，类的函数**只有代码区的一份**，每个对象都有各自的数据，但它们共用类的一份代码。

### 虚析构函数
多态的核心就在于**父类**指针或者引用**指向子类**对象，这样通过父类指针调用虚函数就会有多态的性质，非常方便。
于是产生一个问题，既然我们用的是父类指针，那么析构的时候可以正常析构子类吗，即可以析构掉父类和子类的全部内存而不会**产生内存泄漏**，**很不幸，不可以**。
```cpp
Child c;
Parent *p = &c;
delete p;
```
**只会**调用`~Parent()`即父类的析构函数，因为这是**静态绑定**，`delete`会自动调用析构函数，但是编译器看到的`p`仅仅是个`Parent`类的指针，因此静态绑定到`~Parent()`函数。而**不会表现出多态性质**。

虚析构函数就是为了解决这个问题：为了可以**通过父类指针完整析构子类**。

使用方法很简单，只需要在**父类**的虚构函数前加上`virtual`关键字即可。
```cpp
class Parent
{
public:
	virtual ~Parent()   //写virtual关键字，这是个虚析构函数
	{
		cout << "~Parent!" << endl;
	}
}
class Chlild : public Parent
{
public:
	~Chlild()
	{
		cout << "~Child!" << endl;
	}
}
int main()
{
	Child c;
	Parent* p = &c;
	delete p; // 通过父类指针正确地析构掉了子类，而不会产生内存泄漏，这就是虚析构函数的作用
}
```
构造时先调用`Parent()`再调用`Child()`，析构时先调用`~Child()`再调用`~Parent()`.

### 重载&重写&重定义概念辨析
* 重载必须在**同一个类**中进行，子类无法重载父类的函数，父类的同名函数将被子类覆盖。重载是**静态绑定**的，在编译阶段就确定了。
* 重写必须发生在父类和子类之间，并且重写的函数在父类子类中**类型完全一致**，是通过`virtual`关键字标注的。
* 如果没有`virtual`关键字，那么相当于重定义，这时子类名称会覆盖掉父类，通过**类名限定**可以访问父类的函数。

## 纯虚函数和抽象类
就相当于Java中的接口类，也就是说抽象类中的纯虚函数没有给出实现，子类**必须要重写**纯虚函数才可以。
这部分概念比较简单，主要是应用的问题，emmm设计模式相关了，之后再补充吧。
