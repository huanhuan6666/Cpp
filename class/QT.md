## 简介
* QT的头文件一般和类名一样，并且前两个字母大写
### QApplication
* 每一个QT项目**有且只有**一个`QApplication`类，有点像C语言的main函数
* 并且`exec()`函数实现让程序一直执行，等待事件的发生，如果不调用`exec()`窗口就会一闪而过
* 因此一般的框架都是
```cpp
int main(int argc, char* argv[])
{
  QApplication a(argc, argv);
  //...
  //自己写的代码
  //...
  a.exec();
  return 0; //也可以直接return a.exec();
}
```
### QMainWindow
* 默认带**菜单栏**的窗口，就是一般的PC应用界面。包含：菜单栏、工具栏、状态栏、核心控件以及浮动窗口
* 菜单栏 QMenuBar
  QMainWindow自己就有获取`meanuBar(), statusBar()`等等的公有函数。

### QWidget
* 组件基类，并且默认是隐藏，想要显示必须`show()`出来

### QDialog
* 对话框，窗口大小不能伸缩

### 基本思想
* 典型的OO框架，会面向对象应该没啥问题。
* 组件的构造：每个组件都是继承自`QWidget`类，里面可以**自定义**创建新的属性和函数，以及虚函数**重写**对一些槽函数：也就是**聚合**其他组件，而其他组件同样可以继承后自定义组件的类型，这样就实现了基本的搭建框架
  * 每个组件之间相互独立，组件类可以**指定父对象**，就是基类的一个指针`parent`，可以直接带参数的构造函数，也可以`setParent(this)`。
  * 当组件指定父对象指针为主体时，主体`show()`会自动让这些组件也`show()`出来，非常方便。 
  * 因此一般都把所有的组件绑定`setParent(this)`以及组件各种属性的设定全部放在主体的**构造函数**里，之后使用时创建一个主体对象`show()`出来就OK了
* 分清体用：即确定一个组件类作为主体，其他的都是组件。根据上一条的构造方法，A聚合B，A就是体B就是用。
  * 组件作为主体的一个属性，当然可以被主体所用。主体的`move()`坐标系统是按照屏幕来的，组件的坐标系统是按照其**父对象**来的。
  * 但是组件却无法使用主体的函数，这时只能通过**信号**来解决，如果是简单组件比如`QPushbutton`直接使用标准信号就行，（而复杂组件可能需要自定义`singal:`信号，并且在对应场景下`emit mysingal()`发出信号），在主体内定义对这个信号的槽函数并`connect()`起来就OK了。槽函数也是可以使用标准槽函数，也可以自定义一个成员函数or全局函数。
    * 槽函数就是个**回调函数**，处理信号的具体动作都是这个回调函数实现的。
    * `singals`不是标准C++的关键字，是Qt的拓展；以及`public slots:`关键字也是
    * 自定义的信号有点像函数的声明：只有声明**没有实现**，同样也可以带参数并且可以**重载**
    * 最好让槽函数和信号的**函数类型一致**，因为信号的一个重要功能就是**给槽函数传参**，如果信号涉及重载的话用**函数指针**来进行区分。或者用qt4的方法使用`SIGNAL()`和`SLOT()`宏更方便，不过需要在类里面标注好`signals:`和`public slots:`关键字。
    * 还是直接用lambda表达式吧。。。，槽函数可以写成`[=](){ ... //函数体}`,`[=]`中间的=表示函数体可以把外部所有局部变量和类中的成员变量**值传递**，`()`里面放信号传来的**参数**
  * 信号和槽函数就是Qt实现**类之间通信**的接口
